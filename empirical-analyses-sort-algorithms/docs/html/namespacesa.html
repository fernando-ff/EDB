<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Empirical Analyses: sa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Empirical Analyses
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Search Algorithms analysed in this projct.  
<a href="namespacesa.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a65a3a170cc508e2ffb8ca70de94a42d1"><td class="memItemLeft" align="right" valign="top"><a id="a65a3a170cc508e2ffb8ca70de94a42d1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> = unsigned int</td></tr>
<tr class="memdesc:a65a3a170cc508e2ffb8ca70de94a42d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">just an alias for an integer type. <br /></td></tr>
<tr class="separator:a65a3a170cc508e2ffb8ca70de94a42d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac86a5f3622b49a19b375d6380a5a913a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#ac86a5f3622b49a19b375d6380a5a913a">partition</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:ac86a5f3622b49a19b375d6380a5a913a"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a pivot it divides the array into two parts, elements less than or equal to the pivot and elements greater than or equal to the pivot  <a href="namespacesa.html#ac86a5f3622b49a19b375d6380a5a913a">More...</a><br /></td></tr>
<tr class="separator:ac86a5f3622b49a19b375d6380a5a913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42790da7a80ada78e4eefdecb83728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#a9e42790da7a80ada78e4eefdecb83728">insertion</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:a9e42790da7a80ada78e4eefdecb83728"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple sorting algorithm that works similar to the way you sort playing cards in your hands.  <a href="namespacesa.html#a9e42790da7a80ada78e4eefdecb83728">More...</a><br /></td></tr>
<tr class="separator:a9e42790da7a80ada78e4eefdecb83728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf176de8a1d2b8c142262e58036362c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#aaf176de8a1d2b8c142262e58036362c9">selection</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:aaf176de8a1d2b8c142262e58036362c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning.  <a href="namespacesa.html#aaf176de8a1d2b8c142262e58036362c9">More...</a><br /></td></tr>
<tr class="separator:aaf176de8a1d2b8c142262e58036362c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa781affe7ba3ddcef34d09b543eae147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#aa781affe7ba3ddcef34d09b543eae147">bubble</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:aa781affe7ba3ddcef34d09b543eae147"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.  <a href="namespacesa.html#aa781affe7ba3ddcef34d09b543eae147">More...</a><br /></td></tr>
<tr class="separator:aa781affe7ba3ddcef34d09b543eae147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1507af3198919019772cde4788c0b1b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#a1507af3198919019772cde4788c0b1b1">shell</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:a1507af3198919019772cde4788c0b1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The idea of shellSort is to allow exchange of far items. In shellSort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h’th element is sorted.  <a href="namespacesa.html#a1507af3198919019772cde4788c0b1b1">More...</a><br /></td></tr>
<tr class="separator:a1507af3198919019772cde4788c0b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae439bdfbe92da51836528dd6a5f6d8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#ae439bdfbe92da51836528dd6a5f6d8c0">quicksort</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:ae439bdfbe92da51836528dd6a5f6d8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A divide and conquer algortihm.It picks an element as pivot and partitions the given array around the picked pivot.  <a href="namespacesa.html#ae439bdfbe92da51836528dd6a5f6d8c0">More...</a><br /></td></tr>
<tr class="separator:ae439bdfbe92da51836528dd6a5f6d8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1556721e835aa662c74803d878586b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#a5b1556721e835aa662c74803d878586b">mergesort</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:a5b1556721e835aa662c74803d878586b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A divide and conquer algortihm. It divides divides input array in two halves, calls itself for the two halves and then merges the two sorted halves.  <a href="namespacesa.html#a5b1556721e835aa662c74803d878586b">More...</a><br /></td></tr>
<tr class="separator:a5b1556721e835aa662c74803d878586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a7afe944b44ff5fa3d85f67c711df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesa.html#a38a7afe944b44ff5fa3d85f67c711df6">radix</a> (<a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *first, <a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *last)</td></tr>
<tr class="memdesc:a38a7afe944b44ff5fa3d85f67c711df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered  <a href="namespacesa.html#a38a7afe944b44ff5fa3d85f67c711df6">More...</a><br /></td></tr>
<tr class="separator:a38a7afe944b44ff5fa3d85f67c711df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Search Algorithms analysed in this projct. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa781affe7ba3ddcef34d09b543eae147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa781affe7ba3ddcef34d09b543eae147">&#9670;&nbsp;</a></span>bubble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::bubble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td></td></tr>
    <tr><td class="paramname">last</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e42790da7a80ada78e4eefdecb83728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e42790da7a80ada78e4eefdecb83728">&#9670;&nbsp;</a></span>insertion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::insertion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simple sorting algorithm that works similar to the way you sort playing cards in your hands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to the first element in the array </td></tr>
    <tr><td class="paramname">last</td><td>pointer to the last element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b1556721e835aa662c74803d878586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1556721e835aa662c74803d878586b">&#9670;&nbsp;</a></span>mergesort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::mergesort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A divide and conquer algortihm. It divides divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to the first element in the array </td></tr>
    <tr><td class="paramname">last</td><td>pointer to the last element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac86a5f3622b49a19b375d6380a5a913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86a5f3622b49a19b375d6380a5a913a">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a>* sa::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given a pivot it divides the array into two parts, elements less than or equal to the pivot and elements greater than or equal to the pivot </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>to the first element in the array </td></tr>
    <tr><td class="paramname">last</td><td>pointer to the last element in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type* pointer to the pivot </dd></dl>

</div>
</div>
<a id="ae439bdfbe92da51836528dd6a5f6d8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae439bdfbe92da51836528dd6a5f6d8c0">&#9670;&nbsp;</a></span>quicksort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::quicksort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A divide and conquer algortihm.It picks an element as pivot and partitions the given array around the picked pivot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to the first element in the array </td></tr>
    <tr><td class="paramname">last</td><td>pointer to the last element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38a7afe944b44ff5fa3d85f67c711df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a7afe944b44ff5fa3d85f67c711df6">&#9670;&nbsp;</a></span>radix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::radix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to the first element in the array </td></tr>
    <tr><td class="paramname">last</td><td>pointer to the last element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf176de8a1d2b8c142262e58036362c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf176de8a1d2b8c142262e58036362c9">&#9670;&nbsp;</a></span>selection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::selection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to the first element in the array </td></tr>
    <tr><td class="paramname">last</td><td>pointer to the last element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1507af3198919019772cde4788c0b1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1507af3198919019772cde4788c0b1b1">&#9670;&nbsp;</a></span>shell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sa::shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesa.html#a65a3a170cc508e2ffb8ca70de94a42d1">value_type</a> *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The idea of shellSort is to allow exchange of far items. In shellSort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h’th element is sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td></td></tr>
    <tr><td class="paramname">last</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
